import "operations.eol";

// Annotating Scenarios
var scenarios = UML!UseCase.all.select(i | i.checkStereotypeApplication("GaScenario"));
for(scenario in scenarios)
	scenario.annotate_scenario();

// LQN Processors --> UML Nodes
var xml_processors = `t_processor`.all;
for(element in xml_processors)
	annotate_nodes(element);

// LQN Activity --> UML Message
var activities = `t_activity`.all;
for(element in activities)
	annotate_activity(element);

operation UML!UseCase annotate_scenario()
{
	var stereotype = self.getAppliedStereotypes().selectOne(i | i.name = "GaScenario");
	// Sets Response Time
	var resptime = get_scenario_resptime(self);
	
	resptime.println();
	
	self.setValue(stereotype, "respT", Sequence{resptime.asString()});
	
	// Sets Throughput
	var root = self.getValue(stereotype, "root");
	
	var throughput = root.rep.asDouble() / resptime; 
	
	self.setValue(stereotype, "throughput", Sequence{throughput.asString()});
	
	UML.store().println("Scenario: " + self.name + " ResponseTime: " +
		resptime + " Throughput: " + throughput +  " Stored: ");
}

// Adds utilization to nodes
operation annotate_nodes(proc)
{	
	proc.a_name.println();
	
	var node_object = UML!Node.all.selectOne(i | i.name = proc.a_name);
	var stereotype = node_object.getAppliedStereotypes()
		.selectOne(i | i.name == "GaExecHost");
	
	var utilization = proc.children.flatten
		.select(i | i.name = "result-processor").a_utilization;	
			
	node_object.setValue(stereotype, "utilization", utilization);

	UML.store().println("Processor: " + proc.a_name + " Utilization: " +
		utilization.first + " Stored: ");
}

// Adds service time to messages
operation annotate_activity(activity)
{

	var activity_object = UML!Message.all
		.selectOne(i | i.name = activity.a_name);	
				
	var stereotype = activity_object.getAppliedStereotypes()
		.selectOne(i | i.name == "GaStep");	
		
	var results = activity.children.flatten
		.select(i | i.name = "result-activity");
	
	var service_time = results.`a_service-time`;
	activity_object.setValue(stereotype, "respT", service_time);	
	
	UML.store().println("Activity: " + activity.a_name + " ServiceTime: " +
		service_time.first + " Stored: ");
}

operation get_scenario_resptime(scenario : UML!UseCase)
{		
	// Gets the names of the actors triggering the events in the sequences
	var lifelines = scenario.classifierBehavior.lifelines.select(i | i.checkStereotypeApplication("GaWorkloadEvent"));
	
	if(lifelines.isEmpty())
		throw "Error: GaWorkloadEvent not found in scenario's lifelines";
	
	var types = lifelines.represents.collect(i | i.getType().name);
	
	// Get all the reference task;
	var reference_tasks = `t_task`.all().select(i | i.`a_scheduling` == "ref" and types.includes(i.`a_name`));
	
	var entries = reference_tasks.getChildren("entry");
	var entryPhases = entries.getChildren("entry-phase-activities");
		
	var activities = entryPhases.getChildren("activity");
	var times = activities.getChildren("result-activity").`a_service-time`;	

	times = times.collect(i | i.asDouble());
	
	return times.sum();

}

operation Collection getChildren(name : String)
{
	return self.children.flatten.select(i | i.tagName = name);
}