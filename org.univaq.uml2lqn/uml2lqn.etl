rule Model2Schema 
	transform mod : UML!Model
	to modType : LQN!LqnModelType
	{
		modType.name = mod.name;
		modType.processor ::= UML!Node.all.select(i | i.deployment.notEmpty());
	}
	
rule Node2Processor
	transform s : UML!Node
	to t: LQN!ProcessorType 
	{		
		guard: s.checkStereotype("GaExecHost")	
		// Get all the artifacts having a manifestation
		var tasks = s.deployment.collect(i | i.collectSuppliers()).flatten;
		// Get the object representing the "GaExecHost" stereotype
		var strtypeObj = s.getAppliedStereotypes().selectOne(i | i.name == "GaExecHost");	
		// Stereotype tags 
		var resMult = s.getValue(strtypeObj, "resMult");
		var speedFactor = s.getValue(strtypeObj, "speedFactor");
		var schedulingType = s.getValue(strtypeObj, "otherSchedPolicy");
			
		tasks.first.manifestation.first.collectSuppliers().println();		
		tasks = tasks.select(i | i.manifestation.notEmpty() and 
			isInteracting(i.manifestation.first.collectSuppliers()));			
		
		// Add the sources of the LQN		
		tasks.addAll(UML!Actor.all());
		
		t.name = s.name;
		t.task ::= tasks;
		t.replication = resMult.asBigInteger();
	}

rule Lifeline2Task
	transform artif: UML!Artifact
	to task: LQN!TaskType
	{	
		var manifest = artif.manifestation.first;
		var supplier =  manifest.supplier.first;		
		var lifelns = getLifelines(supplier);
		
		var msgs = lifelns.collect(i | i.
				getElements("MessageOccurrenceSpecification")).flatten;
		
		msgs =  msgs.select(i | i.message.messageSort = UML!MessageSort#synchCall);
		
		task.name = artif.name;
		task.entry ::= msgs;
	}
	
rule Actor2Task
	transform actor: UML!Actor
	to task: LQN!TaskType
	{
		var lifelns = getLifelines(actor);
		task.name = actor.name;
		task.scheduling = LQN!TaskSchedulingType#ref;
	}
	
rule MsgSpec2Entry
	transform msgSpec: UML!MessageOccurrenceSpecification
	to entry: LQN!EntryType
	{
		guard: msgSpec.isReceive()
					
		var lifln = msgSpec.covered.first;
		var bes = lifln.getElements("BehaviorExecutionSpecification");
				
		bes = bes.selectOne(i | i.start = msgSpec and 
					i.finish.isTypeOf(UML!MessageOccurrenceSpecification));
			
		if(bes.isDefined() and bes.getMessages().notEmpty())
		{
			var seq = new Sequence();
			seq.add(bes);		

			entry.entryPhaseActivities = new LQN!PhaseActivities;
			entry.entryPhaseActivities.activity ::= seq;	
		}		
		
		entry.name = msgSpec.name;
		entry.type = LQN!TypeType#PH1PH2;			
	}
	
rule BES2activity
	transform bes: UML!BehaviorExecutionSpecification
	to actv: LQN!ActivityPhasesType
	{
		guard: bes.getMessages().notEmpty()
		
		var msgs = bes.getMessages().sortBy(i | getIndexOf(i));
		msgs = msgs.select(i | i.isSend());	
		
		var calls = msgs.collect(i | buildCall(i.message.receiveEvent.name));
				
		actv.name = bes.name;	
		actv.synchCall = calls;			
	}
	
operation UML!BehaviorExecutionSpecification getMessages(): Collection
{
	var lifeln = self.covered.first;
	
	var msgs = lifeln.getElements("MessageOccurrenceSpecification");
	// @ToDo: Methods to get synchCalls
	msgs = msgs.select(i | i.message.messageSort = UML!MessageSort#synchCall);
	
	var startIdx = getIndexOf(self.start);
	var endIdx = getIndexOf(self.finish);

	return msgs.select(i | startIdx < getIndexOf(i) and endIdx > getIndexOf(i));
}


operation UML!Lifeline getElements(cType: String): Collection	
{
	return self.coveredBy.flatten.
					select(i | i.eClass.name == cType);
}
	
operation getIndexOf(element: UML!NamedElement): Integer
{
	var ownerFragment = element.getOwner().getFragments();
	return ownerFragment.indexOf(element);						
}	
	
	
operation buildCall(dest: String): LQN!ActivityMakingCallType
{
	var call = new LQN!ActivityMakingCallType;
	
	call.dest = dest;
	call.callsMean = "1".asDouble();
	
	return call;
}

operation Any asBigInteger(): Native("java.math.BigInteger")
{
	return new Native("java.math.BigInteger")(self);
}
	
operation UML!Dependency collectSuppliers(): Any
{
	var output = self.collect(i | i.supplier).flatten;
	if(output.size() == 1)
		return output.first;
		
	return output;
}

operation UML!NamedElement checkStereotype(stereotypeName: String): Boolean
{
	return self.getAppliedStereotypes().exists(i|i.name = stereotypeName);
}	

operation isInteracting(element: UML!NamedElement): Boolean
{
	var lifelns = getLifelines(element);
	if(lifelns.isEmpty())
		return false;
	return true;
}

operation getLifelines(element: UML!NamedElement): Collection
{
	// All the lifelines of the Model
	var lifelns = UML!Lifeline.all();
	// Get all the lifelines involving "element"
	return lifelns.select(i | i.represents.type = element);
} 