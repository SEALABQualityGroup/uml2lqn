rule Model2Schema 
	transform uml : UML!Model
	to lqn : LQN!LqnModelType
	{
		lqn.name = uml.name;
		lqn.processor ::= UML!Node.all.select(i | i.deployment.notEmpty());
	}
		
rule Node2Processor
	transform s : UML!Node
	to t: LQN!ProcessorType 
	{		
		guard: s.checkStereotype("GaExecHost")	
		// Get all the artifacts having a manifestation
		var tasks = s.deployment.collect(i | i.collectSuppliers()).flatten;
		// Get the object representing the "GaExecHost" stereotype
		var strtypeObj = s.getAppliedStereotypes().selectOne(i | i.name == "GaExecHost");	
		// Stereotype tags 
		var resMult = s.getValue(strtypeObj, "resMult");
		var speedFactor = s.getValue(strtypeObj, "speedFactor");
		var schedulingType = s.getValue(strtypeObj, "otherSchedPolicy");
		
		// Assumption that an artifact has single manifestation
		tasks = tasks.select(i | i.manifestation.size() == 1);
		tasks = tasks.collect(i | i.manifestation.first.collectSuppliers());
		// Get components involved in an interaction
		tasks = tasks.select(i | isInteracting(i));
		// Add the sources of the LQN		
		tasks.addAll(UML!Actor.all());
		
		t.name = s.name;
		t.task ::= tasks;
		t.replication = resMult.asBigInteger();
	}

rule Actor2Task
	transform actor: UML!Actor
	to task: LQN!TaskType
	{
		var lifelns = getLifelines(actor);
		var msgs = lifelns.collect(i | i.getElements("MessageOccurrenceSpecification")).flatten;
		
		msgs =  msgs.select(i | i.message.messageSort = UML!MessageSort#synchCall);
							
		task.name = actor.name;
		task.scheduling = LQN!TaskSchedulingType#ref;			
		task.entry ::= msgs;
	}

rule Component2Task
	transform comp: UML!Component
	to task: LQN!TaskType
	{		
		var lifelns = getLifelines(comp);	
		var msgs = lifelns.collect(i | i.getElements("MessageOccurrenceSpecification")).flatten;
		msgs = msgs.select(i | i.message.messageSort = UML!MessageSort#synchCall and 
								i.isReceive());																									
		task.name = comp.name;
		task.entry ::= msgs;
	}

rule MsgSpec2Entry
	transform msgSpec: UML!MessageOccurrenceSpecification
	to entry: LQN!EntryType
	{	
		var lifeln = msgSpec.covered.first;
		var lifeType = lifeln.represents.type;
		
		var msg = msgSpec.message.name;				
		var bes = lifeln.getElements("BehaviorExecutionSpecification");
		bes = bes.selectOne(i | i.start = msgSpec and 
									i.finish.isTypeOf(UML!MessageOccurrenceSpecification));
																		
		if(lifeType.isTypeOf(UML!Actor))
			entry.name = "init_" + msg;
		else 
			entry.name = msg;
																	
		var seq = new Sequence();
		seq.add(bes);	
			
		entry.entryPhaseActivities = new LQN!PhaseActivities;
		entry.entryPhaseActivities.activity ::= seq;			 
		entry.type = LQN!TypeType#PH1PH2;	
	}

rule BES2Activity
	transform bes: UML!BehaviorExecutionSpecification
	to actv: LQN!ActivityPhasesType
	{				
		var msgs = bes.getMessages().sortBy(i | getIndexOf(i));			
		msgs = msgs.select(i | i.isSend());				
		
		var calls = msgs.collect(i | buildCall(i.message.name));
	
		if(calls.notEmpty())
			actv.synchCall = calls;	
			
		actv.name = bes.name;
		actv.phase = "1".asBigInteger();
			
	}

operation UML!BehaviorExecutionSpecification getMessages(): Collection
{
	// Gets all the messages of a BehaviorExecutionSpecification
	var lifeln = self.covered.first;
	var msgs = lifeln.getElements("MessageOccurrenceSpecification");
	
	// @ToDo: Methods to get other kind of calls
	msgs = msgs.select(i | i.message.messageSort = UML!MessageSort#synchCall);
		
	var startIdx = getIndexOf(self.start);
	var endIdx = getIndexOf(self.finish);
	
	return msgs.select(i | startIdx <= getIndexOf(i) and endIdx >= getIndexOf(i));
}

operation UML!Lifeline getElements(cType: String): Collection	
{
	// It returns the elements with the type cType in the lifeline
	return self.coveredBy.flatten.
					select(i | i.eClass.name == cType);
}
	
operation getIndexOf(element: UML!NamedElement): Integer
{
	// Returns the index of "element"
	// The elements are contained in a collection of the owner (i.e., the fragment)
	// In the latter, they are ordered by integers
	var ownerFragment = element.getOwner().getFragments();
	return ownerFragment.indexOf(element);						
}	
	
operation buildCall(dest: String): LQN!ActivityMakingCallType
{
	// Create an ActivityMakingCallType setting the callsMean 
	// and the dest
	var call = new LQN!ActivityMakingCallType;
	
	call.dest = dest;
	call.callsMean = "1".asDouble();
	
	return call;
}

operation Any asBigInteger(): Native("java.math.BigInteger")
{
	// Converts an element to the java native type BigInteger
	return new Native("java.math.BigInteger")(self);
}
	
operation UML!Dependency collectSuppliers(): Any
{
	// Given a Dependency, it return a collection of suppliers. 
	// In case it is just one, it returns directly the supplier object
	var output = self.collect(i | i.supplier).flatten;
	if(output.size() == 1)
		return output.first;
		
	return output;
}

operation UML!NamedElement checkStereotype(stereotypeName: String): Boolean
{
	return self.getAppliedStereotypes().exists(i|i.name = stereotypeName);
}	

operation isInteracting(element: UML!NamedElement): Boolean
{
	// Checks if there is at least an interaction describing the behavior 
	// of "element"
	var lifelns = getLifelines(element);
	if(lifelns.isEmpty())
		return false;
	return true;
}

operation getLifelines(element: UML!NamedElement): Collection
{
	// All the lifelines of the Model
	var lifelns = UML!Lifeline.all();
	// Get all the lifelines involving "element"
	return lifelns.select(i | i.represents.type = element);
} 