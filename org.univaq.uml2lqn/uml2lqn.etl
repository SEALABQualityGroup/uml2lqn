rule Model2Schema 
	transform s : UML!Model
	to t : LQN!LqnModelType
	{
		t.name = s.name;
		t.processor ::= UML!Node.all();
		LQN.getElementById("1").println();
	}
	
rule Node2Processor
	transform s : UML!Node
	to t: LQN!ProcessorType 
	{		
		// Apply the transformation only if a Node has at least a deployed artifact
		guard : (not s.deployment.isEmpty()) and s.checkStereotype("GaExecHost")
		
		// Get the object representing the "GaExecHost" stereotype
		var strtypeObj = s.getAppliedStereotypes().selectOne(i | i.name == "GaExecHost");	

		// Stereotype tags 
		var resMult = s.getValue(strtypeObj, "resMult");
		var speedFactor = s.getValue(strtypeObj, "speedFactor");
		var schedulingType = s.getValue(strtypeObj, "otherSchedPolicy");
		
		// The replication attribute has type "BigInteger". This statement performs a cast. 		
		t.name = s.name;
		t.task ::= s.getComponents();
		t.replication = resMult.asBigInteger();
	}

rule Component2Task
	transform s: UML!Component
	to t: LQN!TaskType
	{		
		// A task is created only if a component is involved in an Interaction
		guard : s.getLifelines().notEmpty()

		var liflns = s.getLifelines();
		// Get all the incomings and outcomings messages of a Lifeline
		var entries = liflns.collect(i | i.getCalls()).flatten;
	
		t.name = s.name;
		t.entry ::= entries;
	}
	
rule MsgSpec2Entry
	transform msgSpec: UML!MessageOccurrenceSpecification
	to entry: LQN!EntryType
	{	
		// Messages characteristics
		var relatedMessage = msgSpec.message;
		var msgSort = relatedMessage.messageSort;
		
		var activitySeq = new Sequence();
		var callSeq = new Sequence();
		var activity = new LQN!ActivityPhasesType;
		var call = new LQN!ActivityMakingCallType;
		// Set client and server name
		var clientName = "client_" + relatedMessage.name;
		var serverName = "server_" + relatedMessage.name;
				
		callSeq.add(call);
		
		entry.type = LQN!TypeType#PH1PH2;			
		entry.entryPhaseActivities = new LQN!PhaseActivities;	
		
		activity.phase = "1".asBigInteger();
		
		// Set sender characteristics
		if(relatedMessage.sendEvent == msgSpec)
		{
			entry.name = clientName;		
			activity.name = clientName;
			
			// Set the characteristics of the Activity
			switch(msgSort)
			{	
				case UML!MessageSort#synchCall :
					activity.synchCall = callSeq;
					activity.synchCall.first.dest = serverName;
																		
				case UML!MessageSort#asynchCall :
					activity.asynchCall = callSeq;
					activity.asynchCall.first.dest = serverName;
			}
		}	
		
		// Set receiver characteristics
		if(relatedMessage.receiveEvent == msgSpec)
		{
			activity.name = serverName;
			entry.name = serverName;
		}
			
		activitySeq.add(activity);
		entry.entryPhaseActivities.activity = activitySeq;
					
	}
	

operation Any asBigInteger() : Native("java.math.BigInteger")
{
	return new Native("java.math.BigInteger")(self);
}
	
operation UML!NamedElement checkStereotype(stereotypeName : String): Boolean
{
	return self.getAppliedStereotypes().exists(i|i.name = stereotypeName);
}	

// Get the associated artifact for each deployment of the Node
operation UML!Node getComponents(): Sequence	
{
	// Given a Node, it takes all the deployed artifacts 
	var artifs = self.deployment.collect(i | i.collectSuppliers()).flatten;
	
	// Given an Artifact, it retrieves the related component
	// To Do: Check the existance of the component
	return artifs.collect(i | i.manifestation.first.collectSuppliers()).flatten;
}

operation UML!Dependency collectSuppliers(): Sequence
{
	return self.collect(i | i.supplier).flatten;
}
	
operation UML!Component getLifelines(): Sequence
{
	// All the lifelines of the Model
	var lifelns = UML!Lifeline.all();
	// Get all the lifelines involving "element"
	return lifelns.select(i | i.represents.type == self);
} 

/* 
 * Given a Lifeline it returns all the messages sent and received by the lifeline;
 * The message should have a signature
 * return: a set of UML!MessageOccurrenceSpecification
 */
operation UML!Lifeline getCalls(): Set
{
	// Collects all the MessageOccurrenceSpecification of a Lifeline
	var messages = self.coveredBy.
					select(i | i.isTypeOf(UML!MessageOccurrenceSpecification));
	// It takes only messages having a well-defined signature
	return messages.select(i | i.message.signature.isDefined());	
}	
	 
