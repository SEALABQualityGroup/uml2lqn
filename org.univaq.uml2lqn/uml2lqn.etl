import "operations.eol";

pre
{
	var modelMessages = UML!MessageOccurrenceSpecification.all();
	"Begin Transformation...".println();
}

post
{	
	
	var processors = LQN!ProcessorType.all().select(i | i.task.isEmpty());
	for(processor in processors)
		LQN.deleteElement(processor);
	
	// Checks if all the call are targeting an existing entry
	callsCorrectness();
	"Done!!".println();	
}


rule Model2Schema 
	transform uml: UML!Model
	to lqn: LQN!LqnModelType
	{
		guard: uml.name <> "PrimitiveTypes" and uml.name <> "UML"
		
		uml.name.println("NAME --> ");
		
		lqn.name = uml.name;
							
		var components = getReplicatedComponents();
		
		lqn.processor ::= UML!Node.all();
	}

/*************************************************/
operation cloneCorrectness() : Boolean
{
	var components = getReplicatedComponents();
	
	for(component in components)
	{
		var nodes = component.getNodes();
		var speedFactor = nodes.first.getSpeedFactor();
		
		if(not (nodes.forAll(i|i.getSpeedFactor() = speedFactor)))
			throw "Error: Component " + component.name + "is deployed on nodes with different nodes";
	}
	
	return true;
}


operation callsCorrectness()
{
	for(call in LQN!MakingCallType)
	{
		LQN!EntryType.all().name.println("asd: ");
		call.dest.println("dest:");
		if(not LQN!EntryType.all().name.includes(call.dest))
			throw "Error: call " + call.dest + " to an undefined entry";
	}
}

operation UML!Component getNodes() : Sequence
{
	var artifacts = self.getArtifacts();	
	
	var deployments = artifacts.collect(i | i.getDeployments()).flatten;
	deployments = deployments.collect(i | i.client).flatten;
	
	return deployments;
}

operation getReplicatedComponents() : Sequence
{
	var output = new Sequence();

	for(component in UML!Component.all())
	{		
		var nodes = component.getNodes();
		
		if(nodes.size() > 1 and component.isInteracting())
			output.add(component);
	}
	
	return output;
}

operation UML!Node exclusiveDeployment(component: UML!Component) : Boolean
{
	var artifacts = component.getArtifacts();	
	var deployments = artifacts.collect(i | i.getDeployments()).flatten;
	deployments = deployments.collect(i | i.client).flatten;
	
	if(deployments.size() = 1)
		return true;
			
	return false;
}	
/*************************************************/


rule Node2Processor
	transform node: UML!Node
	to proc: LQN!ProcessorType 
	{	
		/* 
		 * This guard is needed to avoid the following situations: 
		 * - A <<GaExecHost>> Node without deployments
         * - A <<GaExecHost>> Node deploying elements that are not interacting
		 * - Nodes that are not instance of the GaExecHost stereotype
		 */
		guard {
		
			// Gets the components deployed on this Node;
			var components = node.getDeployed();
			// A component interacts if there is at least one lifeline involved in a sequence
			// components = components.select(i | i.isInteracting() and node.exclusiveDeployment(i));
			components = components.select(i | i.isInteracting());
	
			// The transformation considers nodes that are GaExecHost and interacting
			return node.checkStereotypeApplication("GaExecHost") and components.notEmpty();
		}
			
		node.name.println(" Node: ");

		// GaExecHost stereotype object
		var stereotype = node.checkAndGetStereotype("GaExecHost");
		
		var resTag = node.getValue(stereotype, "resMult");
		var speedFactor = node.getValue(stereotype, "speedFactor");
		
		var components = node.getDeployed();
		
		var temp = node.getDeployed();
		temp = temp.select(i | not node.exclusiveDeployment(i));
		
		var temp2 = temp.collect(i | i.getNodes()).flatten;
		var size = temp2.size() == 0 ? "1" else temp2.size().asString();
		
		//components = components.select(i | i.isInteracting() and node.exclusiveDeployment(i));
		components = components.select(i | i.isInteracting());	
		components.name.println();

		var sources = components.collect(i | i.getSources()).flatten;
		
		if(sources.notEmpty()) 
			components.addAll(sources);				
				
		proc.name = node.name;
		proc.task ::= components;
		proc.multiplicity = size.asBigInteger();
		//proc.replication = size.asBigInteger();
	}
	
rule Actor2Task
	transform actor: UML!Actor
	to task: LQN!TaskType
	{
		guard: actor.isInteracting()
		
		var lifelines = actor.getLifelines();
		var beses = lifelines.collect(i | i.getElements("BehaviorExecutionSpecification")).flatten;
				
		task.name = actor.name;
		task.scheduling = LQN!TaskSchedulingType#ref;
		task.entry ::= beses;
	}

rule Component2Task
	transform component: UML!Component
	to task: LQN!TaskType
	{
		guard {
		
			if(component.isInteracting() and component.getArtifacts().isEmpty())
				throw "Component " + component.name + " is not represented by any Artifact";
				
			return component.isInteracting();
		}

		var lifelines = component.getLifelines();
		lifelines = lifelines.select(i | i.isInteracting());
		
		var beses = lifelines.collect(i | i.getElements("BehaviorExecutionSpecification")).flatten;
		
		// var artifacts = component.getArtifacts();
		// var multiplicity = artifacts.size().asString();
			
		task.name = component.name;
		task.entry ::= beses;
		// task.multiplicity = multiplicity.asBigInteger();
	}
	

rule BES2Entry
	transform bes: UML!BehaviorExecutionSpecification
	to entry: LQN!EntryType
	{	
		guard {
			
			if(not (bes.isWellFormed()))
				return false;
			
			// @Assumption: a BES has an exclusive Lifeline
			var lifeline = bes.covered.first;
									
			if(lifeline.isUndefined())
				throw "The BES: " + bes.name + "is not bound to any lifeline";
				
			var type = lifeline.represents.type;
						
			return type.isInteracting();
		}
			
		var messages = bes.getMessages();
		// Gets only the messages that are sent
		messages = messages.select(i | i.isSend() and i.message.messageSort <> UML!MessageSort#reply);	
		
		// If msgs is empty, then the BES is a sink 
		if(messages.isEmpty())
			messages.add(bes.start);
	
		entry.name = bes.name;					
		entry.entryPhaseActivities = new LQN!PhaseActivities;
		entry.entryPhaseActivities.activity ::= messages;
	}


rule Message2Activity
	transform msgo: UML!MessageOccurrenceSpecification
	to actv: LQN!ActivityPhasesType
	{
		guard {
			var message = msgo.message;
			return message.checkStereotypeApplication("GaStep");
		}
		
		var message = msgo.message;
		// Get Stereotype Tags value
		var stereotype = message.checkAndGetStereotype("GaStep");
		var execTime = message.getValue(stereotype, "execTime").first;
		var rep = message.getValue(stereotype, "rep");						
		var hostDemandMean = execTime.asDouble() * rep.asDouble(); 
					
		actv.name = message.name;
		actv.phase = "1".asBigInteger();
		actv.hostDemandMean = hostDemandMean;

		if(msgo.isSend())
		{		
			var call = new LQN!ActivityMakingCallType;		
			var lifeline = message.receiveEvent.covered;
			
			"^^^^^^^^^^".println();
			message.println("Message --> ");
			lifeline.println("Message lifeline --> ");
			
			lifeline.first.name.println("Lifeline first --> ");
			
			/*for(bs in BehaviorExecutionSpecification.all){
				bs.name.println("BES name --> ");
				bs.getCovereds.println("List of covered --> ");
				bs.start.name.println("BES start --> ");
				bs.start.isTypeOf(MessageOccurrenceSpecification).println("BES start type --> ");
				bs.finish.name.println("BES finish --> ");
				bs.finish.isTypeOf(MessageOccurrenceSpecification).println("BES finish type --> ");
				"-----".println();
			}*/
			
			
			// Gets the BES starting with the message
			var bes = lifeline.first.getElements("BehaviorExecutionSpecification");
			bes.println("Lifeline first beses --> ");

			
			message.receiveEvent.getCovered().println("MOS_receive covered of Message --> ");
			for(b in bes){
				b.start.println("BES start --> ");
				message.receiveEvent.println("Message receive --> ");
				b.finish.println("BES finish --> ");
			}
			
			"^^^^^^^^^^".println();


			// Gets the target BES				
			bes = bes.selectOne(i | i.start == message.receiveEvent and
				i.finish.isTypeOf(MessageOccurrenceSpecification));
			
			call.dest = bes.name;
			call.callsMean = rep;
			actv.synchCall = Sequence{call};
		}
	}	