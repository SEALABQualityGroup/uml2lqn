rule Model2Schema 
	transform mod : UML!Model
	to modType : LQN!LqnModelType
	{
		modType.name = mod.name;
		modType.processor ::= UML!Node.all.select(i | i.deployment.notEmpty());
	}
	
rule Node2Processor
	transform s : UML!Node
	to t: LQN!ProcessorType 
	{		
		guard: s.checkStereotype("GaExecHost")	
		// Get all the artifacts having a manifestation
		var tasks = s.deployment.collect(i | i.collectSuppliers()).flatten;
		// Get the object representing the "GaExecHost" stereotype
		var strtypeObj = s.getAppliedStereotypes().selectOne(i | i.name == "GaExecHost");	
		// Stereotype tags 
		var resMult = s.getValue(strtypeObj, "resMult");
		var speedFactor = s.getValue(strtypeObj, "speedFactor");
		var schedulingType = s.getValue(strtypeObj, "otherSchedPolicy");	
		// @ToDo: isInteracting
		tasks = tasks.select(i | i.manifestation.notEmpty());			
		// Add the actors		
		tasks.addAll(UML!Actor.all());
		// The replication attribute has type "BigInteger". This statement performs a cast. 		
		t.name = s.name;
		t.task ::= tasks;
		t.replication = resMult.asBigInteger();
	}

rule Lifeline2Task
	transform artif: UML!Artifact
	to task: LQN!TaskType
	{	
		var manifest = artif.manifestation.first;
		var supplier =  manifest.supplier.first;		
		var lifelns = getLifelines(supplier);
		
		task.name = artif.name;
	}
	
rule Actor2Task
	transform actor: UML!Actor
	to task: LQN!TaskType
	{
		var lifelns = getLifelines(actor);
		
		task.name = actor.name;
		task.scheduling = LQN!TaskSchedulingType#ref;
	}
	
	
operation buildCall(dest: String): 
	LQN!ActivityMakingCallType
{
	var call = new LQN!ActivityMakingCallType;
	
	call.dest = dest;
	call.callsMean = "1".asDouble();
	
	return call;
}

operation Any asBigInteger(): Native("java.math.BigInteger")
{
	return new Native("java.math.BigInteger")(self);
}
	
operation UML!Dependency collectSuppliers(): Any
{
	return self.collect(i | i.supplier).flatten;
}

operation UML!NamedElement checkStereotype(stereotypeName: String): Boolean
{
	return self.getAppliedStereotypes().exists(i|i.name = stereotypeName);
}	

operation isInteracting(element: UML!NamedElement): Boolean
{
	var lifelns = getLifelines(element);
	if(lifelns.isEmpty())
		return false;
	return true;
}

operation getLifelines(element: UML!NamedElement): Sequence
{
	// All the lifelines of the Model
	var lifelns = UML!Lifeline.all();
	// Get all the lifelines involving "element"
	return lifelns.select(i | i.represents.type == element);
} 

operation UML!Lifeline getOutgoing(): Collection
{
	// Collects all the MessageOccurrenceSpecification of a Lifeline
	var allmsgs = self.coveredBy.
					select(i | i.isTypeOf(UML!MessageOccurrenceSpecification));				
	// Collects all the synchCall				
	var msgs = allmsgs.select(i | i.message.messageSort == UML!MessageSort#synchCall);
	// Check if the lifeline sends messages
	return msgs.select(i | i.message.sendEvent == i);				
}	
	 
